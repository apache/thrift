///////////////////////////////////////////////////////////////
// Autogenerated by Thrift Compiler (1.0.0-dev)
//
// DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
///////////////////////////////////////////////////////////////

#[allow(unused_imports)]
use std::collections::{HashMap, HashSet};
use thrift::protocol::{MessageType, Type};
use thrift::transport::Transport;
use thrift::protocol::Protocol;
use thrift::protocol::{Readable, Writeable};
use thrift::TResult;
use thrift::ThriftErr;
use thrift::ThriftErr::*;
use std::num::FromPrimitive;
use thrift::protocol::ProtocolHelpers;

use shared::*;

#[allow(dead_code)]
#[derive(Copy,Show,FromPrimitive)]
pub enum Operation {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
  DIVIDE = 4,
}

impl Operation {
  pub fn new() -> Operation {
    Operation::ADD
  }
}

pub type MyInteger = i32;

#[allow(dead_code)]
#[derive(Show)]
pub struct Work {
  pub num1: i32,
  pub num2: i32,
  pub op: Operation,
  pub comment: Option<String>,
}

impl Work {
  pub fn new() -> Work {
    Work {
      num1: 0,
      num2: 0,
      op: Operation::new(),
      comment: None,
    }
  }
}

impl Writeable for Work {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Work");

    oprot.write_field_begin(transport, "num1", Type::TI32, 1);
    oprot.write_i32(transport, self.num1);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "num2", Type::TI32, 2);
    oprot.write_i32(transport, self.num2);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "op", Type::TI32, 3);
    oprot.write_i32(transport, self.op as i32);
    oprot.write_field_end(transport);
    
    match self.comment {
      Some(ref  x) => {
        oprot.write_field_begin(transport, "comment", Type::TString, 4);
        oprot.write_string(transport, x);
        oprot.write_field_end(transport);
      }
      _ => {}
    }
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

impl Readable for Work {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 1) => {
          self.num1 = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, Type::TI32, 2) => {
          self.num2 = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, Type::TI32, 3) => {
          self.op = try!(ProtocolHelpers::read_enum(iprot, transport));
          have_result = true;
        }
        /*
        (_, Type::TString, 4) => {
          self.comment = try!(iprot.read_string(transport));
          have_result = true;
        }
        */
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ProtocolError) }
  }
}

#[allow(dead_code)]
#[derive(Show)]
pub struct InvalidOperation {
  pub what: i32,
  pub why: String,
}

impl InvalidOperation {
  pub fn new() -> InvalidOperation {
    InvalidOperation {
      what: 0,
      why: String::new(),
    }
  }
}

impl Writeable for InvalidOperation {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "InvalidOperation");

    oprot.write_field_begin(transport, "what", Type::TI32, 1);
    oprot.write_i32(transport, self.what);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "why", Type::TString, 2);
    oprot.write_string(transport, &self.why);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

impl Readable for InvalidOperation {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 1) => {
          self.what = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, Type::TString, 2) => {
          self.why = try!(iprot.read_string(transport));
          have_result = true;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ProtocolError) }
  }
}

#[allow(dead_code)]
#[derive(Show)]
pub struct CalculatorPingArgs;

impl Writeable for CalculatorPingArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_ping_args");

    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Show)]
pub struct CalculatorPingResult;

impl CalculatorPingResult {
  pub fn new() -> CalculatorPingResult {
    CalculatorPingResult
  }
}

impl Readable for CalculatorPingResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = true;
    iprot.read_struct_begin(transport);
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ProtocolError) }
  }
}

#[allow(dead_code)]
#[derive(Show)]
pub struct CalculatorAddArgs {
  pub num1: i32,
  pub num2: i32,
}

impl Writeable for CalculatorAddArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_add_args");

    oprot.write_field_begin(transport, "num1", Type::TI32, 1);
    oprot.write_i32(transport, self.num1);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "num2", Type::TI32, 2);
    oprot.write_i32(transport, self.num2);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Show)]
pub struct CalculatorAddResult {
  pub success: i32,
}

impl CalculatorAddResult {
  pub fn new() -> CalculatorAddResult {
    CalculatorAddResult {
      success: 0,
    }
  }
}

impl Readable for CalculatorAddResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 0) => {
          self.success = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ProtocolError) }
  }
}

#[allow(dead_code)]
#[derive(Show)]
pub struct CalculatorCalculateArgs {
  pub logid: i32,
  pub w: Work,
}

impl Writeable for CalculatorCalculateArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_calculate_args");

    oprot.write_field_begin(transport, "logid", Type::TI32, 1);
    oprot.write_i32(transport, self.logid);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "w", Type::TStruct, 2);
    self.w.write(oprot, transport);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Show)]
pub struct CalculatorCalculateResult {
  pub success: i32,
  pub ouch: Option<InvalidOperation>,
}

impl CalculatorCalculateResult {
  pub fn new() -> CalculatorCalculateResult {
    CalculatorCalculateResult {
      success: 0,
      ouch: None,
    }
  }
}

impl Readable for CalculatorCalculateResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 0) => {
          self.success = try!(iprot.read_i32(transport));
          have_result = true;
        }
        /*
        (_, Type::TStruct, 1) => {
          try!(self.ouch.read(iprot, transport));
          have_result = true;
        }
        */
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ProtocolError) }
  }
}

#[allow(dead_code)]
#[derive(Show)]
pub struct CalculatorZipArgs;

impl Writeable for CalculatorZipArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_zip_args");

    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

pub trait CalculatorClient {
  #[allow(non_snake_case)]
  fn ping(
    &mut self,
    ) -> TResult<()>;
  #[allow(non_snake_case)]
  fn add(
    &mut self,
    num1: i32,
    num2: i32,
    ) -> TResult<i32>;
  #[allow(non_snake_case)]
  fn calculate(
    &mut self,
    logid: i32,
    w: Work,
    ) -> TResult<i32>;
  #[allow(non_snake_case)]
  fn zip(
    &mut self,
    ) -> TResult<()>;
  #[allow(non_snake_case)]
  fn getStruct(
    &mut self,
    key: i32,
    ) -> TResult<SharedStruct>;
}

pub struct CalculatorClientImpl<P: Protocol, T: Transport> {
  pub protocol: P,
  pub transport: T,
}

impl <P: Protocol, T: Transport> CalculatorClientImpl<P, T> {
  pub fn new(protocol: P, transport: T) -> CalculatorClientImpl<P, T> {
    CalculatorClientImpl {
      protocol: protocol,
      transport: transport,
    }
  }
}

impl <P: Protocol, T: Transport> CalculatorClient for CalculatorClientImpl<P, T> {

  #[allow(non_snake_case)]
  fn ping(
    &mut self,
    ) -> TResult<()> {
      let args = CalculatorPingArgs;
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "ping", MessageType::MtCall, &args));
      let mut result = CalculatorPingResult::new();
      try!(ProtocolHelpers::receive(&self.protocol, &mut self.transport, "ping", &mut result));
      Ok(())
  }

  #[allow(non_snake_case)]
  fn add(
    &mut self,
    num1: i32,
    num2: i32,
    ) -> TResult<i32> {
      let args = CalculatorAddArgs {
      num1: num1,
      num2: num2,
      };
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "add", MessageType::MtCall, &args));
      let mut result = CalculatorAddResult::new();
      try!(ProtocolHelpers::receive(&self.protocol, &mut self.transport, "add", &mut result));
      Ok(result.success)
  }

  #[allow(non_snake_case)]
  fn calculate(
    &mut self,
    logid: i32,
    w: Work,
    ) -> TResult<i32> {
      let args = CalculatorCalculateArgs {
      logid: logid,
      w: w,
      };
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "calculate", MessageType::MtCall, &args));
      let mut result = CalculatorCalculateResult::new();
      try!(ProtocolHelpers::receive(&self.protocol, &mut self.transport, "calculate", &mut result));
      Ok(result.success)
  }

  #[allow(non_snake_case)]
  fn zip(
    &mut self,
    ) -> TResult<()> {
      let args = CalculatorZipArgs;
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "zip", MessageType::MtCall, &args));
      Ok(())
  }

  #[allow(non_snake_case)]
  fn getStruct(
    &mut self,
    key: i32,
    ) -> TResult<SharedStruct> {
      let args = SharedServiceGetStructArgs {
      key: key,
      };
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "getStruct", MessageType::MtCall, &args));
      let mut result = SharedServiceGetStructResult::new();
      try!(ProtocolHelpers::receive(&self.protocol, &mut self.transport, "getStruct", &mut result));
      Ok(result.success)
  }

}

