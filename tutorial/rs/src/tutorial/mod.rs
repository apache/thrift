///////////////////////////////////////////////////////////////
// Autogenerated by Thrift Compiler (1.0.0-dev)
//
// DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
///////////////////////////////////////////////////////////////

#[allow(unused_imports)]
use thrift::TResult;
#[allow(unused_imports)]
use std::collections::{HashMap, HashSet};
#[allow(unused_imports)]
use thrift::protocol::{MessageType, Type};
use thrift::transport::Transport;
use thrift::protocol::Protocol;
#[allow(unused_imports)]
use thrift::protocol::Readable;

#[allow(dead_code)]
#[derive(Copy)]
pub enum Operation {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
  DIVIDE = 4,
}

pub type MyInteger = i32;

#[allow(dead_code)]
pub struct Work {
  pub num1: i32,
  pub num2: i32,
  pub op: Operation,
  pub comment: Option<String>,
}

impl Work {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Work");

    oprot.write_field_begin(transport, "num1", Type::TI32, 1);
    oprot.write_i32(transport, self.num1);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "num2", Type::TI32, 2);
    oprot.write_i32(transport, self.num2);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "op", Type::TI32, 3);
    oprot.write_i32(transport, self.op as i32);
    oprot.write_field_end(transport);
    
    match self.comment {
      Some(ref  x) => {
        oprot.write_field_begin(transport, "comment", Type::TString, 4);
        oprot.write_string(transport, x);
        oprot.write_field_end(transport);
      }
      _ => {}
    }
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

#[allow(dead_code)]
pub struct InvalidOperation {
  pub what: i32,
  pub why: String,
}

impl InvalidOperation {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "InvalidOperation");

    oprot.write_field_begin(transport, "what", Type::TI32, 1);
    oprot.write_i32(transport, self.what);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "why", Type::TString, 2);
    oprot.write_string(transport, &self.why);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

#[allow(dead_code)]
pub struct CalculatorPingArgs;

impl CalculatorPingArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_ping_args");

    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);

    Ok(())
  }

}

#[allow(dead_code)]
pub struct CalculatorAddArgs {
  pub num1: i32,
  pub num2: i32,
}

impl CalculatorAddArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Calculator_add_args");

    oprot.write_field_begin(transport, "num1", Type::TI32, 1);
    oprot.write_i32(transport, self.num1);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "num2", Type::TI32, 2);
    oprot.write_i32(transport, self.num2);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

#[allow(dead_code)]
pub struct CalculatorCalculateArgs {
  pub logid: i32,
  pub w: Work,
}

impl CalculatorCalculateArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Calculator_calculate_args");

    oprot.write_field_begin(transport, "logid", Type::TI32, 1);
    oprot.write_i32(transport, self.logid);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "w", Type::TStruct, 2);
    self.w.write(oprot, transport);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}


#[allow(dead_code)]
pub struct CalculatorZipArgs;

impl CalculatorZipArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Calculator_zip_args");

    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

