///////////////////////////////////////////////////////////////
// Autogenerated by Thrift Compiler (1.0.0-dev)
//
// DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
///////////////////////////////////////////////////////////////

#[allow(unused_imports)]
use std::collections::{HashMap, HashSet};
use std::rc::Rc;
use std::cell::RefCell;
use thrift::processor::Processor;
use thrift::protocol::{Protocol, MessageType, Type};
use thrift::transport::Transport;
use thrift::protocol::{Readable, Writeable, ProtocolHelpers};
use thrift::TResult;
#[allow(unused_imports)]
use thrift::ThriftErr;
#[allow(unused_imports)]
use thrift::ThriftErr::*;
#[allow(unused_imports)]
use thrift::protocol::Error;
#[allow(unused_imports)]
use thrift::protocol::Error::*;
#[allow(unused_imports)]
use thrift::protocol::FromNum;

use shared::*;

#[allow(dead_code)]
#[derive(PartialEq,Eq,Hash,Copy,Clone,Debug)]
pub enum Operation {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
  DIVIDE = 4,
}

impl FromNum for Operation {
  fn from_num(num: i32) -> Option<Operation> {
    match num {
      1 => Some(Operation::ADD),
      2 => Some(Operation::SUBTRACT),
      3 => Some(Operation::MULTIPLY),
      4 => Some(Operation::DIVIDE),
      _ => None,
    }
  }
}

impl Operation {
  #[allow(dead_code)]
  pub fn new() -> Operation {
    Operation::ADD
  }
}

pub type MyInteger = i32;

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Work {
  pub num1: i32,
  pub num2: i32,
  pub op: Operation,
  pub comment: Option<String>,
}

impl Work {
  #[allow(dead_code)]
  pub fn new() -> Work {
    Work {
      num1: 0,
      num2: 0,
      op: Operation::new(),
      comment: None,
    }
  }
}

impl Writeable for Work {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "Work"));

    try!(oprot.write_field_begin(transport, "num1", Type::TI32, 1));
    try!(oprot.write_i32(transport, self.num1));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_begin(transport, "num2", Type::TI32, 2));
    try!(oprot.write_i32(transport, self.num2));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_begin(transport, "op", Type::TI32, 3));
    try!(oprot.write_i32(transport, self.op as i32));
    try!(oprot.write_field_end(transport));
    
    match self.comment {
      Some(ref x) => {
        try!(oprot.write_field_begin(transport, "comment", Type::TString, 4));
        try!(oprot.write_string(transport, x));
        try!(oprot.write_field_end(transport));
      }
      _ => {}
    }
    
    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

impl Readable for Work {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 1) => {
          self.num1 = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, Type::TI32, 2) => {
          self.num2 = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, Type::TI32, 3) => {
          self.op = try!(ProtocolHelpers::read_enum(iprot, transport));
          have_result = true;
        }
        /* FIXME
        (_, Type::TString, 4) => {
          self.comment = Some(try!(iprot.read_string(transport)));
          have_result = true;
        }
        */
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InvalidOperation {
  pub what_op: i32,
  pub why: String,
}

impl InvalidOperation {
  #[allow(dead_code)]
  pub fn new() -> InvalidOperation {
    InvalidOperation {
      what_op: 0,
      why: String::new(),
    }
  }
}

impl Writeable for InvalidOperation {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "InvalidOperation"));

    try!(oprot.write_field_begin(transport, "whatOp", Type::TI32, 1));
    try!(oprot.write_i32(transport, self.what_op));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_begin(transport, "why", Type::TString, 2));
    try!(oprot.write_string(transport, &self.why));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

impl Readable for InvalidOperation {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 1) => {
          self.what_op = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, Type::TString, 2) => {
          self.why = try!(iprot.read_string(transport));
          have_result = true;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CalculatorPingArgs;

impl CalculatorPingArgs {
  #[allow(dead_code)]
  pub fn new() -> CalculatorPingArgs {
    CalculatorPingArgs
  }
}

impl Readable for CalculatorPingArgs {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let have_result = true;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

impl Writeable for CalculatorPingArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "Calculator_ping_args"));

    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CalculatorPingResult;

impl CalculatorPingResult {
  #[allow(dead_code)]
  pub fn new() -> CalculatorPingResult {
    CalculatorPingResult
  }
}

impl Readable for CalculatorPingResult {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let have_result = true;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

impl Writeable for CalculatorPingResult {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "Calculator_ping_result"));

    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CalculatorAddArgs {
  pub num1: i32,
  pub num2: i32,
}

impl CalculatorAddArgs {
  #[allow(dead_code)]
  pub fn new() -> CalculatorAddArgs {
    CalculatorAddArgs {
      num1: 0,
      num2: 0,
    }
  }
}

impl Readable for CalculatorAddArgs {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 1) => {
          self.num1 = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, Type::TI32, 2) => {
          self.num2 = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

impl Writeable for CalculatorAddArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "Calculator_add_args"));

    try!(oprot.write_field_begin(transport, "num1", Type::TI32, 1));
    try!(oprot.write_i32(transport, self.num1));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_begin(transport, "num2", Type::TI32, 2));
    try!(oprot.write_i32(transport, self.num2));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CalculatorAddResult {
  pub success: i32,
}

impl CalculatorAddResult {
  #[allow(dead_code)]
  pub fn new() -> CalculatorAddResult {
    CalculatorAddResult {
      success: 0,
    }
  }
}

impl Readable for CalculatorAddResult {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 0) => {
          self.success = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

impl Writeable for CalculatorAddResult {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "Calculator_add_result"));

    try!(oprot.write_field_begin(transport, "success", Type::TI32, 0));
    try!(oprot.write_i32(transport, self.success));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CalculatorCalculateArgs {
  pub logid: i32,
  pub w: Work,
}

impl CalculatorCalculateArgs {
  #[allow(dead_code)]
  pub fn new() -> CalculatorCalculateArgs {
    CalculatorCalculateArgs {
      logid: 0,
      w: Work::new(),
    }
  }
}

impl Readable for CalculatorCalculateArgs {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 1) => {
          self.logid = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, Type::TStruct, 2) => {
          try!(self.w.read(iprot, transport));
          have_result = true;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

impl Writeable for CalculatorCalculateArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "Calculator_calculate_args"));

    try!(oprot.write_field_begin(transport, "logid", Type::TI32, 1));
    try!(oprot.write_i32(transport, self.logid));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_begin(transport, "w", Type::TStruct, 2));
    try!(self.w.write(oprot, transport));
    try!(oprot.write_field_end(transport));
    
    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CalculatorCalculateResult {
  pub success: i32,
  pub ouch: Option<InvalidOperation>,
}

impl CalculatorCalculateResult {
  #[allow(dead_code)]
  pub fn new() -> CalculatorCalculateResult {
    CalculatorCalculateResult {
      success: 0,
      ouch: None,
    }
  }
}

impl Readable for CalculatorCalculateResult {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 0) => {
          self.success = try!(iprot.read_i32(transport));
          have_result = true;
        }
        /* FIXME
        (_, Type::TStruct, 1) => {
          try!(self.ouch.read(iprot, transport));
          have_result = true;
        }
        */
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

impl Writeable for CalculatorCalculateResult {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "Calculator_calculate_result"));

    try!(oprot.write_field_begin(transport, "success", Type::TI32, 0));
    try!(oprot.write_i32(transport, self.success));
    try!(oprot.write_field_end(transport));
    
    match self.ouch {
      Some(ref x) => {
        try!(oprot.write_field_begin(transport, "ouch", Type::TStruct, 1));
        try!(x.write(oprot, transport));
        try!(oprot.write_field_end(transport));
      }
      _ => {}
    }
    
    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CalculatorZipArgs;

impl CalculatorZipArgs {
  #[allow(dead_code)]
  pub fn new() -> CalculatorZipArgs {
    CalculatorZipArgs
  }
}

impl Readable for CalculatorZipArgs {

  #[allow(unused_mut)]
  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let have_result = true;
    try!(iprot.read_struct_begin(transport));
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ThriftErr::from(Error::ProtocolViolation)) }
  }
}

impl Writeable for CalculatorZipArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    try!(oprot.write_struct_begin(transport, "Calculator_zip_args"));

    try!(oprot.write_field_stop(transport));
    try!(oprot.write_struct_end(transport));
    Ok(())
  }

}

pub trait CalculatorClient : SharedServiceClient {
  #[allow(non_snake_case)]
  fn ping(
    &mut self,
    ) -> TResult<()>;
  #[allow(non_snake_case)]
  fn add(
    &mut self,
    num1: i32,
    num2: i32,
    ) -> TResult<i32>;
  #[allow(non_snake_case)]
  fn calculate(
    &mut self,
    logid: i32,
    w: Work,
    ) -> TResult<i32>;
  #[allow(non_snake_case)]
  fn zip(
    &mut self,
    ) -> TResult<()>;
}

#[allow(dead_code)]
#[derive(Debug)]
pub struct CalculatorClientImpl<P: Protocol, T: Transport> {
  pub protocol: P,
  pub transport: T,
}

impl <P: Protocol, T: Transport> CalculatorClientImpl<P, T> {
  #[allow(dead_code)]
  pub fn new(protocol: P, transport: T) -> CalculatorClientImpl<P, T> {
    CalculatorClientImpl {
      protocol: protocol,
      transport: transport,
    }
  }
}

impl <P: Protocol, T: Transport> CalculatorClient for CalculatorClientImpl<P, T> {

  #[allow(non_snake_case)]
  fn ping(
    &mut self,
    ) -> TResult<()> {
      let args = CalculatorPingArgs;
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "ping", MessageType::MtCall, &args));
      let mut result = CalculatorPingResult::new();
      try!(ProtocolHelpers::receive(&self.protocol, &mut self.transport, "ping", &mut result));
      Ok(())
  }

  #[allow(non_snake_case)]
  fn add(
    &mut self,
    num1: i32,
    num2: i32,
    ) -> TResult<i32> {
      let args = CalculatorAddArgs {
        num1: num1,
        num2: num2,
      };
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "add", MessageType::MtCall, &args));
      let mut result = CalculatorAddResult::new();
      try!(ProtocolHelpers::receive(&self.protocol, &mut self.transport, "add", &mut result));
      Ok(result.success)
  }

  #[allow(non_snake_case)]
  fn calculate(
    &mut self,
    logid: i32,
    w: Work,
    ) -> TResult<i32> {
      let args = CalculatorCalculateArgs {
        logid: logid,
        w: w,
      };
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "calculate", MessageType::MtCall, &args));
      let mut result = CalculatorCalculateResult::new();
      try!(ProtocolHelpers::receive(&self.protocol, &mut self.transport, "calculate", &mut result));
      Ok(result.success)
  }

  #[allow(non_snake_case)]
  fn zip(
    &mut self,
    ) -> TResult<()> {
      let args = CalculatorZipArgs;
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "zip", MessageType::MtCall, &args));
      Ok(())
  }

}

impl <P: Protocol, T: Transport> SharedServiceClient for CalculatorClientImpl<P, T> {

  #[allow(non_snake_case)]
  fn getStruct(
    &mut self,
    key: i32,
    ) -> TResult<SharedStruct> {
      let args = SharedServiceGetStructArgs {
        key: key,
      };
      try!(ProtocolHelpers::send(&self.protocol, &mut self.transport, "getStruct", MessageType::MtCall, &args));
      let mut result = SharedServiceGetStructResult::new();
      try!(ProtocolHelpers::receive(&self.protocol, &mut self.transport, "getStruct", &mut result));
      Ok(result.success)
  }

}

pub trait CalculatorIf : SharedServiceIf
 {
  #[allow(non_snake_case)]
  fn ping(
    &mut self,
    ) -> ();

  #[allow(non_snake_case)]
  fn add(
    &mut self,
    num1: i32,
    num2: i32,
    ) -> i32;

  #[allow(non_snake_case)]
  fn calculate(
    &mut self,
    logid: i32,
    w: Work,
    ) -> i32;

  #[allow(non_snake_case)]
  fn zip(
    &mut self,
    ) -> ();

}

pub struct CalculatorProcessor<I: CalculatorIf> {
  parent: SharedServiceProcessor<I>,
  iface: Rc<RefCell<I>>
}
impl<I: CalculatorIf, P: Protocol, T: Transport> Processor<P, T> for CalculatorProcessor<I> {
  fn process(&mut self, prot: &mut P, transport: &mut T) -> TResult<()> {
    let (name, ty, id) = try!(prot.read_message_begin(transport));
    self.dispatch(prot, transport, name, ty, id)
  }
}
impl<I: CalculatorIf> CalculatorProcessor<I> {
  #[allow(dead_code)]
  pub fn new(iface: Rc<RefCell<I>>) -> Self {
    CalculatorProcessor {
      parent: SharedServiceProcessor::new(iface.clone()),
      iface: iface,
    }
  }
  pub fn dispatch<P: Protocol, T: Transport>(&mut self, prot: &mut P, transport: &mut T, name: String, ty: MessageType, id: i32) -> TResult<()> {
    match &*name {
      "ping" => self.ping(prot, transport, ty, id),
      "add" => self.add(prot, transport, ty, id),
      "calculate" => self.calculate(prot, transport, ty, id),
      "zip" => self.zip(prot, transport, ty, id),
      _ => self.parent.dispatch(prot, transport, name, ty, id)
    }
  }
  #[allow(unused_mut)]
  #[allow(non_snake_case)]
  fn ping<P: Protocol, T: Transport>(&mut self, prot: &mut P, transport: &mut T, ty: MessageType, id: i32) -> TResult<()> {
    let mut args = CalculatorPingArgs::new();
    try!(ProtocolHelpers::receive_body(prot, transport, "ping" , &mut args, "ping", ty, id));
    let mut result = CalculatorPingResult::new();
    self.iface.borrow_mut().ping(
    );
    try!(ProtocolHelpers::send(prot, transport, "ping", MessageType::MtReply, &result));
    Ok(())
  }

  #[allow(unused_mut)]
  #[allow(non_snake_case)]
  fn add<P: Protocol, T: Transport>(&mut self, prot: &mut P, transport: &mut T, ty: MessageType, id: i32) -> TResult<()> {
    let mut args = CalculatorAddArgs::new();
    try!(ProtocolHelpers::receive_body(prot, transport, "add" , &mut args, "add", ty, id));
    let mut result = CalculatorAddResult::new();
    result.success =     self.iface.borrow_mut().add(
      args.num1,
      args.num2,
    );
    try!(ProtocolHelpers::send(prot, transport, "add", MessageType::MtReply, &result));
    Ok(())
  }

  #[allow(unused_mut)]
  #[allow(non_snake_case)]
  fn calculate<P: Protocol, T: Transport>(&mut self, prot: &mut P, transport: &mut T, ty: MessageType, id: i32) -> TResult<()> {
    let mut args = CalculatorCalculateArgs::new();
    try!(ProtocolHelpers::receive_body(prot, transport, "calculate" , &mut args, "calculate", ty, id));
    let mut result = CalculatorCalculateResult::new();
    result.success =     self.iface.borrow_mut().calculate(
      args.logid,
      args.w,
    );
    try!(ProtocolHelpers::send(prot, transport, "calculate", MessageType::MtReply, &result));
    Ok(())
  }

  #[allow(unused_mut)]
  #[allow(non_snake_case)]
  fn zip<P: Protocol, T: Transport>(&mut self, prot: &mut P, transport: &mut T, ty: MessageType, id: i32) -> TResult<()> {
    let mut args = CalculatorZipArgs::new();
    try!(ProtocolHelpers::receive_body(prot, transport, "zip" , &mut args, "zip", ty, id));
    Ok(())
  }

}
