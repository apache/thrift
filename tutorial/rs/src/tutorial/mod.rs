///////////////////////////////////////////////////////////////
// Autogenerated by Thrift Compiler (1.0.0-dev)
//
// DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
///////////////////////////////////////////////////////////////

#[allow(unused_imports)]
use std::collections::{HashMap, HashSet};
use thrift::protocol::{MessageType, Type};
use thrift::transport::Transport;
use thrift::protocol::Protocol;
use thrift::protocol::Readable;

#[allow(dead_code)]
#[derive(Copy)]
pub enum Operation {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
  DIVIDE = 4,
}

pub type MyInteger = i32;

#[allow(dead_code)]
pub struct Work {
  pub num1: i32,
  pub num2: i32,
  pub op: Operation,
  pub comment: Option<String>,
}

impl Work {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Work");

    oprot.write_field_begin(transport, "num1", Type::TI32, 1);
    oprot.write_i32(transport, self.num1);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "num2", Type::TI32, 2);
    oprot.write_i32(transport, self.num2);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "op", Type::TI32, 3);
    oprot.write_i32(transport, self.op as i32);
    oprot.write_field_end(transport);
    
    match self.comment {
      Some(ref  x) => {
        oprot.write_field_begin(transport, "comment", Type::TString, 4);
        oprot.write_string(transport, x);
        oprot.write_field_end(transport);
      }
      _ => {}
    }
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

#[allow(dead_code)]
pub struct InvalidOperation {
  pub what: i32,
  pub why: String,
}

impl InvalidOperation {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "InvalidOperation");

    oprot.write_field_begin(transport, "what", Type::TI32, 1);
    oprot.write_i32(transport, self.what);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "why", Type::TString, 2);
    oprot.write_string(transport, &self.why);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

#[allow(dead_code)]
pub struct CalculatorPingArgs;

impl CalculatorPingArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Calculator_ping_args");

    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

#[allow(dead_code)]
pub struct CalculatorPingResult;

impl Readable for CalculatorPingResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> bool {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      let (fname, ftype, fid) = iprot.read_field_begin(transport);
      if ftype == Type::TStop {
        break;
      }
      match (fid, ftype) {
        _ => {
          iprot.skip(transport, ftype);
        }
      }
      iprot.read_field_end(transport);
    }
    iprot.read_struct_end(transport);
    have_result
  }
}

#[allow(dead_code)]
pub struct CalculatorAddArgs {
  pub num1: i32,
  pub num2: i32,
}

impl CalculatorAddArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Calculator_add_args");

    oprot.write_field_begin(transport, "num1", Type::TI32, 1);
    oprot.write_i32(transport, self.num1);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "num2", Type::TI32, 2);
    oprot.write_i32(transport, self.num2);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

#[allow(dead_code)]
pub struct CalculatorAddResult {
  pub success: i32,
}

impl Readable for CalculatorAddResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> bool {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      let (fname, ftype, fid) = iprot.read_field_begin(transport);
      if ftype == Type::TStop {
        break;
      }
      match (fid, ftype) {
        (0, Type::TI32) => {
          self.success = iprot.read_i32(transport);
          have_result = true
        }
        _ => {
          iprot.skip(transport, ftype);
        }
      }
      iprot.read_field_end(transport);
    }
    iprot.read_struct_end(transport);
    have_result
  }
}

#[allow(dead_code)]
pub struct CalculatorCalculateArgs {
  pub logid: i32,
  pub w: Work,
}

impl CalculatorCalculateArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Calculator_calculate_args");

    oprot.write_field_begin(transport, "logid", Type::TI32, 1);
    oprot.write_i32(transport, self.logid);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "w", Type::TStruct, 2);
    self.w.write(oprot, transport);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

#[allow(dead_code)]
pub struct CalculatorCalculateResult {
  pub success: i32,
  pub ouch: Option<InvalidOperation>,
}

impl Readable for CalculatorCalculateResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> bool {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      let (fname, ftype, fid) = iprot.read_field_begin(transport);
      if ftype == Type::TStop {
        break;
      }
      match (fid, ftype) {
        (0, Type::TI32) => {
          self.success = iprot.read_i32(transport);
          have_result = true
        }
        _ => {
          iprot.skip(transport, ftype);
        }
      }
      iprot.read_field_end(transport);
    }
    iprot.read_struct_end(transport);
    have_result
  }
}

#[allow(dead_code)]
pub struct CalculatorZipArgs;

impl CalculatorZipArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  pub fn write(&self, oprot: &Protocol, transport: &mut Transport) {
    oprot.write_struct_begin(transport, "Calculator_zip_args");

    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
  }

}

