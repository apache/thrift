///////////////////////////////////////////////////////////////
// Autogenerated by Thrift Compiler (1.0.0-dev)
//
// DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
///////////////////////////////////////////////////////////////

#[allow(unused_imports)]
use std::collections::{HashMap, HashSet};
use thrift::protocol::{MessageType, Type};
use thrift::transport::Transport;
use thrift::protocol::Protocol;
use thrift::protocol::{Readable, Writeable};
use thrift::TResult;use thrift::ThriftErr;use thrift::ThriftErr::*;
#[allow(dead_code)]
#[derive(Copy)]
pub enum Operation {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
  DIVIDE = 4,
}

pub type MyInteger = i32;

#[allow(dead_code)]
pub struct Work {
  pub num1: i32,
  pub num2: i32,
  pub op: Operation,
  pub comment: Option<String>,
}

impl Writeable for Work {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Work");

    oprot.write_field_begin(transport, "num1", Type::TI32, 1);
    oprot.write_i32(transport, self.num1);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "num2", Type::TI32, 2);
    oprot.write_i32(transport, self.num2);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "op", Type::TI32, 3);
    oprot.write_i32(transport, self.op as i32);
    oprot.write_field_end(transport);
    
    match self.comment {
      Some(ref  x) => {
        oprot.write_field_begin(transport, "comment", Type::TString, 4);
        oprot.write_string(transport, x);
        oprot.write_field_end(transport);
      }
      _ => {}
    }
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

#[allow(dead_code)]
pub struct InvalidOperation {
  pub what: i32,
  pub why: String,
}

impl Writeable for InvalidOperation {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "InvalidOperation");

    oprot.write_field_begin(transport, "what", Type::TI32, 1);
    oprot.write_i32(transport, self.what);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "why", Type::TString, 2);
    oprot.write_string(transport, &self.why);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

#[allow(dead_code)]
pub struct CalculatorPingArgs;

impl Writeable for CalculatorPingArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_ping_args");

    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

#[allow(dead_code)]
pub struct CalculatorPingResult;

impl Readable for CalculatorPingResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = true;
    iprot.read_struct_begin(transport);
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ProtocolError) }
  }
}

#[allow(dead_code)]
pub struct CalculatorAddArgs {
  pub num1: i32,
  pub num2: i32,
}

impl Writeable for CalculatorAddArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_add_args");

    oprot.write_field_begin(transport, "num1", Type::TI32, 1);
    oprot.write_i32(transport, self.num1);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "num2", Type::TI32, 2);
    oprot.write_i32(transport, self.num2);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

#[allow(dead_code)]
pub struct CalculatorAddResult {
  pub success: i32,
}

impl Readable for CalculatorAddResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 0) => {
          self.success = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ProtocolError) }
  }
}

#[allow(dead_code)]
pub struct CalculatorCalculateArgs {
  pub logid: i32,
  pub w: Work,
}

impl Writeable for CalculatorCalculateArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_calculate_args");

    oprot.write_field_begin(transport, "logid", Type::TI32, 1);
    oprot.write_i32(transport, self.logid);
    oprot.write_field_end(transport);
    
    oprot.write_field_begin(transport, "w", Type::TStruct, 2);
    self.w.write(oprot, transport);
    oprot.write_field_end(transport);
    
    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

#[allow(dead_code)]
pub struct CalculatorCalculateResult {
  pub success: i32,
  pub ouch: Option<InvalidOperation>,
}

impl Readable for CalculatorCalculateResult {

  fn read(& mut self, iprot: &Protocol, transport: & mut Transport) -> TResult<()> {
    let mut have_result = false;
    iprot.read_struct_begin(transport);
    loop {
      match try!(iprot.read_field_begin(transport)) {
        (_, Type::TStop, _) => {
          try!(iprot.read_field_end(transport));
          break;
        }
        (_, Type::TI32, 0) => {
          self.success = try!(iprot.read_i32(transport));
          have_result = true;
        }
        (_, ftype, _) => {
          try!(iprot.skip(transport, ftype));
        }
      }
      try!(iprot.read_field_end(transport));
    }
    try!(iprot.read_struct_end(transport));
    if have_result { Ok(()) } else { Err(ProtocolError) }
  }
}

#[allow(dead_code)]
pub struct CalculatorZipArgs;

impl Writeable for CalculatorZipArgs {

  #[allow(unused_variables)]
  #[allow(dead_code)]
  fn write(&self, oprot: &Protocol, transport: &mut Transport) -> TResult<()> {
    oprot.write_struct_begin(transport, "Calculator_zip_args");

    oprot.write_field_stop(transport);
    oprot.write_struct_end(transport);
    Ok(())
  }

}

