using System;
using System.Net;
using System.Threading.Tasks;
using System.Threading;
using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift;
namespace DroHub.Helpers.Thrift
{
    public class TMessageValidatorProtocol : TProtocolDecorator
    {
        /**
        * TMessageValidatorProtocol is a protocol-independent concrete decorator that allows a Thrift
        * client to communicate with a Server and validate that the messaged received is matching the
        * sent seqid. If it does not match we keep reading the buffer or throw an exception.
        * This Protocol Decorator provides the most advantage with a framed transport.
        * By default Thrift processors only provide an incrementing seqid that always starts in 0,
        * which can lead to collisions when 2 protocols are started at the same time over the same
        * transport.
        * To mitigate that this protocol also overrides the seqid normally generated by the processor,
        * because it uses a random seq id to avoid shared channel seqid collisions.
        */
        private const int _MAGIC_NUMBER = 21474347;
        private int _random_seq_id;
        public enum ValidationModeEnum
        {
            KEEP_READING,
            THROW_EXCEPTION
        }
        public enum OperationModeEnum
        {
            SEQID_SLAVE,
            SEQID_MASTER
        }
        public ValidationModeEnum ValidationMode { get; set; }
        public OperationModeEnum OperationMode{ get;}
    public TMessageValidatorProtocol(TProtocol protocol, ValidationModeEnum validation_mode, OperationModeEnum operation_mode)
            : base(protocol)
        {
            ValidationMode = validation_mode;
            OperationMode = operation_mode;
            var rand = new Random();
            _random_seq_id = rand.Next();
        }

        private async Task ReadMagicNumber(CancellationToken cancellationToken)
        {
            byte[] HeaderBuffer = new byte[1];
            int result = 0;
            do
            {
                var d = await Trans.ReadAsync(HeaderBuffer, 0, 1);
                result = result << 8 | (int)HeaderBuffer[0];
                // Console.WriteLine($"buffer read {d} in {HeaderBuffer[0]}-> {result} or {_MAGIC_NUMBER} == {result == _MAGIC_NUMBER}");
            } while (!cancellationToken.IsCancellationRequested && result != _MAGIC_NUMBER);
        }
        private async Task WriteMagicNumber(CancellationToken cancellationToken) {
            byte[] bytes = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(_MAGIC_NUMBER));
            await Trans.WriteAsync(bytes, 0, 4);
        }
        public override async Task WriteMessageBeginAsync(TMessage message, CancellationToken cancellationToken)
        {
            if (OperationMode == OperationModeEnum.SEQID_MASTER)
            {
                _random_seq_id++;
                message.SeqID = _random_seq_id;
            }
            else if (OperationMode == OperationModeEnum.SEQID_SLAVE) {
                ;
            }
            else{
                throw new TProtocolException(TProtocolException.NOT_IMPLEMENTED, "Invalid operation mode selected");
            }

            // Console.WriteLine("Writing");
            await WriteMagicNumber(cancellationToken);
            await base.WriteMessageBeginAsync(message, cancellationToken);
        }
        public override async ValueTask<TMessage> ReadMessageBeginAsync(CancellationToken cancellationToken)
        {
            await ReadMagicNumber(cancellationToken);
            TMessage new_message = await base.ReadMessageBeginAsync(cancellationToken);
            // Console.WriteLine($"seq id {_random_seq_id} == {new_message.SeqID}");
            while (_random_seq_id != new_message.SeqID)
            {
                if (ValidationMode == ValidationModeEnum.KEEP_READING)
                {
                    // Console.WriteLine("Re reading");
                    await ReadMagicNumber(cancellationToken);
                    new_message = await base.ReadMessageBeginAsync(cancellationToken);
                }
                else if (ValidationMode == ValidationModeEnum.THROW_EXCEPTION)
                    throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "Received SeqID and sent one do not match.");
                else
                    throw new InvalidProgramException("This is an unreachable situation");
            }
            return new_message;
        }
    }
}
